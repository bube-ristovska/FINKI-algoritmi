//package LABAIPS;

import java.util.*;
import java.util.stream.Collectors;

class SLLNode<E> {
	protected E element;
	protected SLLNode<E> succ;

	public SLLNode(E elem, SLLNode<E> succ) {
		this.element = elem;
		this.succ = succ;
	}

	@Override
	public String toString() {
		return element.toString();
	}
}

interface Queue<E> {

	// Elementi na redicata se objekti od proizvolen tip.

	// Metodi za pristap:

	public boolean isEmpty ();
	// Vrakja true ako i samo ako redicata e prazena.

	public int size ();
	// Ja vrakja dolzinata na redicata.

	public E peek ();
	// Go vrakja elementot na vrvot t.e. pocetokot od redicata.

	// Metodi za transformacija:

	public void clear ();
	// Ja prazni redicata.

	public void enqueue (E x);
	// Go dodava x na kraj od redicata.

	public E dequeue ();
	// Go otstranuva i vrakja pochetniot element na redicata.

}
class LinkedQueue<E> implements Queue<E> {

	// Redicata e pretstavena na sledniot nacin:
	// length go sodrzi brojot na elementi.
	// Elementite se zachuvuvaat vo jazli dod SLL
	// front i rear se linkovi do prviot i posledniot jazel soodvetno.
	SLLNode<E> front, rear;
	int length;

	// Konstruktor ...

	public LinkedQueue () {
		clear();
	}

	public boolean isEmpty () {
		// Vrakja true ako i samo ako redicata e prazena.
		return (length == 0);
	}

	public int size () {
		// Ja vrakja dolzinata na redicata.
		return length;
	}

	public E peek () {
		// Go vrakja elementot na vrvot t.e. pocetokot od redicata.
		if (front == null)
			throw new NoSuchElementException();
		return front.element;
	}

	public void clear () {
		// Ja prazni redicata.
		front = rear = null;
		length = 0;
	}

	public void enqueue (E x) {
		// Go dodava x na kraj od redicata.
		SLLNode<E> latest = new SLLNode<E>(x, null);
		if (rear != null) {
			rear.succ = latest;
			rear = latest;
		} else
			front = rear = latest;
		length++;
	}

	public E dequeue () {
		// Go otstranuva i vrakja pochetniot element na redicata.
		if (front != null) {
			E frontmost = front.element;
			front = front.succ;
			if (front == null)  rear = null;
			length--;
			return frontmost;
		} else
			throw new NoSuchElementException();
	}

}


class GraphNode<E> {
	private int index;//index (reden broj) na temeto vo grafot
	private E info;
	private LinkedList<GraphNode<E>> neighbors;

	public GraphNode(int index, E info) {
		this.index = index;
		this.info = info;
		neighbors = new LinkedList<GraphNode<E>>();
	}

	boolean containsNeighbor(GraphNode<E> o){
		return neighbors.contains(o);
	}

	void addNeighbor(GraphNode<E> o){
		neighbors.add(o);
	}

	void removeNeighbor(GraphNode<E> o){
		if(neighbors.contains(o))
			neighbors.remove(o);
	}

	@Override
	public String toString() {
		String ret= "INFO:"+info+" SOSEDI:";
		for(int i=0;i<neighbors.size();i++)
			ret+=neighbors.get(i).info+" ";
		return ret;

	}

	@Override
	public boolean equals(Object obj) {
		@SuppressWarnings("unchecked")
		GraphNode<E> pom = (GraphNode<E>)obj;
		return (pom.info.equals(this.info));
	}

	public int getIndex() {
		return index;
	}

	public void setIndex(int index) {
		this.index = index;
	}

	public E getInfo() {
		return info;
	}

	public void setInfo(E info) {
		this.info = info;
	}

	public LinkedList<GraphNode<E>> getNeighbors() {
		return neighbors;
	}

	public void setNeighbors(LinkedList<GraphNode<E>> neighbors) {
		this.neighbors = neighbors;
	}



}

class Graph<E> {

	int num_nodes;
	GraphNode<E> adjList[];

	@SuppressWarnings("unchecked")
	public Graph(int num_nodes, E[] list) {
		this.num_nodes = num_nodes;
		adjList = (GraphNode<E>[]) new GraphNode[num_nodes];
		for (int i = 0; i < num_nodes; i++)
			adjList[i] = new GraphNode<E>(i, list[i]);
	}

	@SuppressWarnings("unchecked")
	public Graph(int num_nodes) {
		this.num_nodes = num_nodes;
		adjList = (GraphNode<E>[]) new GraphNode[num_nodes];
	}

	int adjacent(int x, int y) {
		// proveruva dali ima vrska od jazelot so
		// indeks x do jazelot so indeks y
		return (adjList[x].containsNeighbor(adjList[y])) ? 1 : 0;
	}

	void addEdge(int x, int y) {
		// dodava vrska od jazelot so indeks x do jazelot so indeks y
		if (!adjList[x].containsNeighbor(adjList[y])) {
			adjList[x].addNeighbor(adjList[y]);
		}
	}

	void deleteEdge(int x, int y) {
		adjList[x].removeNeighbor(adjList[y]);
	}

	void dfsSearch(int node) {
		boolean visited[] = new boolean[num_nodes];
		for (int i = 0; i < num_nodes; i++)
			visited[i] = false;
		dfsRecursive(node, visited);
	}

	void dfsRecursive(int node, boolean visited[]) {
		visited[node] = true;
		System.out.println(node + ": " + adjList[node].getInfo());

		for (int i = 0; i < adjList[node].getNeighbors().size(); i++) {
			GraphNode<E> pom = adjList[node].getNeighbors().get(i);
			if (!visited[pom.getIndex()])
				dfsRecursive(pom.getIndex(), visited);
		}
	}

	void dfsNonrecursive(int node) {
		boolean visited[] = new boolean[num_nodes];
		for (int i = 0; i < num_nodes; i++)
			visited[i] = false;
		visited[node] = true;
		System.out.println(node+": " + adjList[node].getInfo());
		Stack<Integer> s = new Stack<Integer>();
		s.push(node);

		GraphNode<E> pom;

		while (!s.isEmpty()) {
			pom = adjList[s.peek()];
			GraphNode<E> tmp=null;
			for (int i = 0; i < pom.getNeighbors().size(); i++) {
				tmp = pom.getNeighbors().get(i);
				if (!visited[tmp.getIndex()])
					break;
			}
			if(tmp!=null && !visited[tmp.getIndex()]){
				visited[tmp.getIndex()] = true;
				System.out.println(tmp.getIndex() + ": " + tmp.getInfo());
				s.push(tmp.getIndex());
			}
			else
				s.pop();
		}

	}

	void bfs(int node){
		boolean visited[] = new boolean[num_nodes];
		for (int i = 0; i < num_nodes; i++)
			visited[i] = false;
		visited[node] = true;
		System.out.println(node+": " + adjList[node].getInfo());
		Queue<Integer> q = new LinkedQueue<Integer>();
		q.enqueue(node);

		GraphNode<E> pom;

		while(!q.isEmpty()){
			pom = adjList[q.dequeue()];
			GraphNode<E> tmp=null;
			for (int i = 0; i < pom.getNeighbors().size(); i++) {
				tmp = pom.getNeighbors().get(i);
				if (!visited[tmp.getIndex()]){
					visited[tmp.getIndex()] = true;
					System.out.println(tmp.getIndex()+": " + tmp.getInfo());
					q.enqueue(tmp.getIndex());
				}
			}


		}

	}


	@Override
	public String toString() {
		String ret = new String();
		for (int i = 0; i < this.num_nodes; i++)
			ret += i + ": " + adjList[i] + "\n";
		return ret;
	}

}

class Pole{
	int name;
	int x;
	int y;

	public Pole(int name, int x, int y) {
		this.name = name;
		this.x = x;
		this.y = y;
	}

	@Override
	public String toString() {
		return "Pole{" +
				"x=" + x +
				", y=" + y +
				'}';
	}
}
class Maze{
	Graph<Integer> graph;
	int start_node;
	int end_node;
	Pole start, end;
	Hashtable<String, Pole> hashtable;

	public Maze() {
		this.hashtable = new Hashtable<>();
	}

	void generateGraph(int rows, int columns, String [] in){
		int num_nodes = 0;
		//tuka gi chuvash i kako pole za koordinnatite
		String key;

		for(int i=1; i<rows; i++){
			for(int j=1; j<columns; j++){
				if(in[i].charAt(j)!='#'){
					key = i+","+j;
					hashtable.put(key, new Pole(num_nodes, i, j));
					if(in[i].charAt(j)=='S'){
						start_node = num_nodes;
						start = new Pole(num_nodes, i, j);
					}
					if(in[i].charAt(j)=='E'){
						end_node = num_nodes;
						end = new Pole(num_nodes, i, j);
					}
					num_nodes++;
				}
			}
		}

		Integer niza[] = new Integer[num_nodes];
		for (int i = 0; i < num_nodes; i++) {
			niza[i] = i;
		}

		graph = new Graph<Integer>(num_nodes, niza);

		int x;
		int y;
		for(int i=1; i<rows; i++){
			for(int j=1; j<columns; j++){
				if(in[i].charAt(j)!='#'){
					//dali ima teme pred nego
					if(in[i].charAt(j-1)!='#'){
						x = hashtable.get(i+","+j).name;
						y = hashtable.get(i+","+(j-1)).name;
						graph.addEdge(x, y);
					}
					//dali ima teme posle nego
					if(in[i].charAt(j+1)!='#'){
						x = hashtable.get(i+","+j).name;
						y = hashtable.get(i+","+(j+1)).name;
						graph.addEdge(x, y);
					}
					//dali ima teme nad nego
					if(in[i-1].charAt(j)!='#'){
						x = hashtable.get(i+","+j).name;
						y = hashtable.get((i-1)+","+j).name;
						graph.addEdge(x, y);
					}
					//dali ima teme pod nego
					if(in[i+1].charAt(j)!='#'){
						x = hashtable.get(i+","+j).name;
						y = hashtable.get((i+1)+","+j).name;
						graph.addEdge(x, y);
					}
				}
			}
		}
	}

	void findPath() {
		boolean visited[] = new boolean[graph.num_nodes];
		for (int i = 0; i < graph.num_nodes; i++)
			visited[i] = false;
		visited[start_node] = true;
		Stack<Integer> s = new Stack<Integer>();
		s.push(start_node);

		int pom;
		while (!s.isEmpty() && s.peek() != end_node) {
			pom = s.peek();
			int pom1 = pom;
			for (int i = 0; i < graph.num_nodes; i++) {
				if (graph.adjacent(pom, i) == 1) {
					pom1 = i;
					if (!visited[i])
						break;
				}
			}
			if (!visited[pom1]) {
				visited[pom1] = true;
				//System.out.println(pom1.getIndex() + ": " + pom1.getInfo());
				s.push(pom1);
			} else
				s.pop();
		}
		if (s.isEmpty())
			System.out.println("Nema reshenie");
		else {
			Stack<Integer> os = new Stack<Integer>();
			while (!s.isEmpty())
				os.push(s.pop());
			while (!os.isEmpty())
				getFromHash(os.pop());
				//System.out.println(os.pop());
		}
	}

	void getFromHash(int name){
		Collection<Pole> vrednosti = hashtable.values();
		List<Pole> lista = vrednosti.stream().collect(Collectors.toList());
		for (int i = 0; i < graph.num_nodes; i++) {
			if(lista.get(i).name == name) System.out.println(lista.get(i).x + ","  + lista.get(i).y);
		}
	}
}

public class GraphTester {

	/**
	 * @param args
	 */
	public static void main(String args[]){
		Maze m = new Maze();
		Scanner scanner = new Scanner(System.in);
		String line = scanner.nextLine();
		String[] deleno = line.split(",");
		int rows = Integer.parseInt(deleno[0]);
		int columns = Integer.parseInt(deleno[1]);

		String[] in = new String[rows];

		for (int i = 0; i < rows; i++) {
			in[i] = scanner.nextLine();
		}
		scanner.close();

		m.generateGraph(rows, columns, in);
		//System.out.println("Pateka:");
		m.findPath();
	}

}
